[
  "return [$, $$, $$$]",
  "return Object.keys($$$)",
  "$$$.inited = () => $$.state\n$$$.loadjson = async () =>\n  await load(JSON.parse(await (await fetch(\"101.json\")).text()))\n$$$.current = async () => log(await read($$.name))",
  "$$$.forrg = (e, f, s = 0, d = 1) => {\n  if (d > 0) for (let i = s; i < e; i += d) f(i)\n  else for (let i = s; i > e; i += d) f(i) }\n$$$.maprg = (e, f, s, d, a = []) =>\n  ($.forrg(e, i => a.push(f(i)), s, d), a)\n$$$.forin = (o, f) => { for (const k in o) f(o[k], k) }\n$$$.forof = (o, f) => { for (const v of o) f(v) }\n$$$.cases = (h, ...t) => ((m, d) => (c, ...a) =>\n  m.has(c) ? m.get(c)(...a) : d(...a))(new Map(t), h)\n$$$.panic = e => { throw isstr(e) ? Error(e) : e }",
  "$$$.isstr = v => typeof v === \"string\"\n$$$.isobj = v => typeof v === \"object\"\n$$$.isfct = v => typeof v === \"function\"\n$$$.isarr = Array.isArray\n$$$.isnth = v => v===undefined || v==null",
  "document.body.onclick = () => { forward() }\ndocument.body.oncontextmenu = e => { backward(), e.preventDefault() }",
  "const _upage = (e, v) => isobj(v)\n  ? style(e, v) : isstr(v) ? e.innerText = v : 0\nconst upage = o=> d=> forin(o, (e, k, v = d[k])=> isnth(v) ? 0\n  : isarr(v) ? forof(v, v => _upage(e, v)) : _upage(e, v))\nconst init = o=>_=>forin(o, e=>e.removeAttribute(\"style\"))\n$$$.defpage= (n, o)=> ($[\"pi\"+n] = init(o),\n  $[\"p\"+n] = upage(o), $[\"pf\"+n] = f=>f(o))",
  "skip(inited)\nexec({$})((await (await fetch(\"../external/marked.min.js\")).text()) + \"\\n\" + \"$.marked = marked\")",
  "skip(inited)\nstyle(document.body, {width:\"100%\", height:\"100%\"})\n$$$.body = document.body.attachShadow({mode:\"open\"})",
  "skip(inited)\nconst csselm = dom(\"style\", {parent:body})\nconst px = v => isnum(v) ? `${v}px` : v\nconst hyphenate = s => s.replace(/[A-Z]/g, m => `-${m.toLowerCase()}`)\nconst content = s => Object.keys(s)\n  .reduce((p, k) => p + `${hyphenate(k)}: ${px(s[k])}; `, \"\")\n$$$.cssinit = e => (r, ...s) => { e.sheet.insertRule(\n  `${r} { ${s.map(v => content(v)).join(\" \")}}`) }\n$$$.css = $$$.cssinit(csselm)",
  "skip(inited)\nstyle(document.html, {overflow:\"hidden\"})\nstyle(document.body, {overflow:\"hidden\"})\nstyle(document.body, {position:\"relative\", userSelect:\"none\"})\n\ncss(\".page\", { width:\"100%\" })\ncss(\".page\", {textAlign:\"center\", position:\"absolute\"})\ncss(\".page\", {transition:\"all 0.5s\"})\ncss(\".content\", {transition:\"all 0.5s\"})\ncss(\".inline\", {display:\"inline\"})\ncss(\".absolute\", {postion:\"absolute\"})",
  "skip(inited)\nconst top = dom(\"div\", {class:\"page\", parent:body})\nconst t = dom(\"div\", {class:\"content\", parent:top})\nconst subt = dom(\"div\", {class:\"content\", parent:top})\nconst subt1 = dom(\"div\", {class:\"content inline\", parent:subt})\nconst subt2 = dom(\"div\", {class:\"content inline\", parent:subt})\nconst subt3 = dom(\"div\", {class:\"content inline\", parent:subt})\nconst au = dom(\"div\", {class:\"content\", parent:top})\nconst i1 = dom(\"li\", {class: \"content\", parent:top})\nconst i2 = dom(\"li\", {class: \"content\", parent:top})\nconst i3 = dom(\"li\", {class: \"content\", parent:top})\nconst i4 = dom(\"li\", {class: \"content\", parent:top})\n\ndefpage(1, {top, t, subt, subt1, subt2, subt3, au, i1, i2, i3, i4})",
  "skip(inited)\nconst top = dom(\"div\", {class:\"page\", parent:body})\nconst t = dom(\"div\", {class:\"content\", parent:top})\nconst t2 = dom(\"div\", {class:\"content\", parent:top})\nconst i1 = dom(\"div\", {class: \"content\", parent:top})\nconst i2 = dom(\"div\", {class: \"content\", parent:top})\nconst i3 = dom(\"div\", {class: \"content\", parent:top})\nconst i4 = dom(\"div\", {class: \"content\", parent:top})\nconst i5 = dom(\"div\", {class: \"content\", parent:top})\ndefpage(2, {top, t, t2, i1, i2, i3, i4, i5})",
  "skip(inited)\nconst top = dom(\"div\", {class:\"page\", parent:body})\nconst t = dom(\"div\", {class:\"content\", parent:top})\nconst repl = dom(\"div\", {class:\"content\", parent:top})\nfullrepl(repl, {name:\"envjs 101 demo 1\"})\ndefpage(3, {top, t, repl})",
  "skip(inited); {\nconst top = dom(\"div\", {class:\"page\", parent:body})\nconst s = top.attachShadow({mode:\"open\"})\nconst csselm = dom(\"style\", {parent:s})\nconst t = dom(\"div\", {parent:s})\nconst css = cssinit(csselm); $.css4 = css\ncss(\"div\", {transition:\"all 0.5s\"})\ndefpage(4, {top, t}) }",
  "$.init1 = () => { $.pi1(), $.pi2()\n\n$.p1({ t:\"env.js 101\", \n    subt1:\"——\",\n    subt2:\"交互式开发\",\n    subt3:\"工具介绍\",\n       i1:\"vscode ?\",\n       i2:\"chrome devtools ?\",\n       i3:\"某种语言的交互式命令环境?\",\n       i4:\"我很想简单地回答它们属不属于交互式开发，\" +\n\"但那无益于介绍这个概念，让我们换种思路，暂时忘记我们熟悉的所有开发工具，\" +\n\"从基本的东西开始思考……\",\n       au:\"ch3coohlink@2021\"})\n$.p2({\n  t:\"交互是什么？\",\n  t2:\"为什么交互可以发生？\",\n  i1:\"交互，就是我们控制计算机的方式。\",\n  i2:\"点一下按钮是交互\",\n  i3:\"按一下键盘是交互\",\n  i4:\"触摸一下手机屏幕，当然也是交互\",\n})\n\nlet i = {textAlign:\"left\", margin:\"150vh 10%\", fontSize:\"3em\"}\n$.p1({\n  top: {top:\"30%\"},\n  t: {fontSize:\"10em\", height:220, overflow:\"hidden\"},\n  subt: {fontSize:\"3em\", textAlign:\"right\", margin:\"1em 10%\"},\n  i1:i, i2:i, i3:i, i4:i, //这样还是有点麻烦\n  subt1: {fontSize:\"1em\"},\n  au: [{fontSize:\"2em\", textAlign:\"right\", margin:\"3em 10%\"},\n       {height:\"2em\", overflow:\"hidden\"}],\n})\ni = { margin:\"150vh 10%\", fontSize:\"2.5em\",height:50, overflow:\"hidden\"}\n$.p2({\n  top: {top:\"200vh\"},\n  demo: {width:500, heigth:500},\n  t: {fontSize:\"9em\", height:200, overflow:\"hidden\"},\n  t2: {fontSize:\"9em\", height:0, overflow:\"hidden\"},\n  i1:i, i2:i, i3:i, i4:i\n})\n}",
  "$.init2 = () => { $.pi3(), $.pi4()\n$.p3({\n  top: {left: \"200vw\", top:\"20%\"},\n  t: [\"在进一步深入之前，让我们先来体验一下env.js\",\n     {fontSize:50, margin:\"20px auto\"}],\n  repl: {height:800, width:\"80%\", margin:\"50vh auto\", opacity:\"0\"},\n})\n$.p4({\n  top: [{left: \"200vw\", top:\"0%\", height:\"100%\", textAlign:\"justify\"},\n    {boxSizing:\"border-box\", padding:\"30px 10%\", overflow:\"auto\", userSelect:\"text\"}],\n  t: {fontSize:\"2em\"},\n})\n$.pf4(({t}) => {\n  t.innerHTML = $.marked(`\n（请先忘记前面写的所有内容，我修改了整个演示的大纲，但已经来不及做完整的PPT了，所以只好先用这种形式来讲）\n\n---\n# Env.js 一种基于REPL的软件工程实践\n* 今天主要从三个方面来讨论\\`env.js(暂名)\\`对软件工程带来的可能的改进\n  * 怎么写？即用何种形式编写软件\n  * 怎么用？即如何使用以及测试软件\n  * 怎么读？即如何与人交流软件的代码\n  * 这三个问题之间互有联系，所以会穿插着讲\n---\n## 怎么写？\n* REPL是什么？\n  * 有很多种程序表示形式，从常见的文本形式，到节点化等非传统的形式\n  * 这里不讨论其他形式，直接进入对REPL程序形式的分析\n  * REPL，即Read Eval Print Loop的缩写，常见于各种脚本语言的交互式环境中\n  * 比如浏览器调试工具里自带的控制台，就是一个REPL\n\n* REPL有什么特别的？比起编程工具，它看起来更像是调试工具才对？\n* 对，它首先是个调试工具，但它具有的特点实际上可以让它成为一个很好的编程工具\n  1. REPL可以在运行时修改程序功能，具有非常强的交互性\n  2. REPL强制用户进行命令的分割，从而使每条命令都成为一个对程序状态的**有意义**的修改\n  3. REPL的数据结构非常简单，容易对其进行编程\n\n* 这些特点使得REPL可以实现：\n  * 使程序的开发和使用一体化，这一点留到下一部分详细讨论\n  * 进行灵活的状态切换\n    * 先提个问题，如何使程序回到上个一条命令时的状态？\n  * 通过在REPL里调用REPL实现各种编程模式：\n    * 模块\n    * 对象\n    * worker线程\n    * REPL监听其他REPL\n    * REPL作为编译的产物\n    * ……\n    * 如果有时间回到这里解释每个模式\n---\n## 怎么用？\n  * 这里提出一个概念叫软件开发和软件使用的一体化\n    * 以这个PPT为例，这是一个web app，现在我正在使用它\n    * 如果按下alt+\\`键，就会打开这个webapp对应的repl（再按一次隐藏）\n    * 如果改变repl里的命令，ppt的内容也会相应改变，这说明我在进行这个web app的开发\n    * 在交互区点左键，ppt就会前进，这实际上是在repl里前进了一条命令\n    * 在交互区点右键，ppt就会后退，这实际上是在repl里后退了一条命令\n    * 所以在repl里直接做对应的事情，也会得到完全一样的效果（tab前进一条命令，shift+tab后退一条命令）\n\n* 这意味着什么？\n* 意味着很多\n  * 首先，我们拥有了一个通用的操作历史记录\n    * 以图像处理软件为例子，我们对图像的每个操作实际上就对应REPL中的一条命令\n    * 如果将所有的REPL命令运行完，我们就会得到最终的图像\n    * 这种历史记录是极其灵活的，在不同的场景下，有不同的含义\n    * 比如对于PPT编辑这个场景，历史记录实际上是我们对文本的编辑操作，而REPL是我们编辑的数据本身\n  * 其次，我们可以最小化UI层的开发量\n    * 这次问三个问题，以下的在图像处理软件中的哪几项操作应当被记录到历史记录中？\n      1. 用画笔画一条线\n      2. 改变图层顺序\n      3. 改变图层混合属性\n    * 在PhotoShop中，答案是全部都被记录了，但是，让我们从REPL的角度观察这个问题\n    * 我们可以把每个图层看作一个单独的REPL，每个都具有单独的命令列表\n    * 因此，只有画线的操作需要被记录，而其余两个操作只是改变了REPL里的一个属性数据，并不是真正的命令\n    * （P.S: 终于，我们有机会修正把线稿画错图层的痛苦了，只要把相应的画笔操作移到正确的图层即可）\n\n  * 那么这和UI层的开发量有什么关系？\n    * 这里有必要解释一下我对于开发工作量的认识\n    * 程序就是数据结构加算法，相信这是我们的共识\n    * 我的观察是，数据结构限定了我们能做的事情的可能性，我们的操作做得再多，也不可能超出数据能表示的范围\n    * 反过来说，数据所表示的可能性越简单，我们能做的事情也就越单纯\n    * 在传统的模型里，由于UI本身引入了额外的数据，我们的很多操作其实只是在维护UI数据的正确性\n    * 而在上面这个例子里可以看到，我们通过REPL这个模型区分了数据与操作，将数据还原回了最简单的形式\n    * 从而，我们得以简化我们的概念模型，只去编写那些真正重要的操作\n\n  * 另外有一点值得一提，如果一个操作并不需要大量重复执行，那我们甚至可以不去暴露UI，直接使用代码操作就好，这也能减少一部分开发量\n\n  * 最后，虽然有点废话，但还是写清楚，这套模型允许我们把所有的工具放到一个篮子里，没有任何与领域有关的假设，有的仅仅是最原始的数据，以及在它之上的操作\n\n---\n## 怎么读？\n* 文学编程可能吗？\n\n  * 文学编程是Donald Knuth在80年代发明的一种编程方法\n  * 基本上就是把代码混在TeX里面写，按照文本的思路与逻辑去组织代码\n  * 同时要维护一些代码之间的位置引用，使得编译代码之前可以把代码处理成实际执行时需要的顺序\n  * 我对文学编程的实际使用方式没有太大兴趣，但是我很乐于思考文学编程的愿景：\n  * **我们可以像打开一本小说那样，打开一个代码库，跟随作者的思路，一点点理解整个代码库的功能**\n  * 这件事情，不是说在现有的文学编程工具中绝对做不到，但有着极高的开发成本\n  * （你看PBRT一版要花多久，现实中的软件几乎不可能这么做）\n  * （同时也并不是每个人都能接受这种特殊的代码阅读方式）\n  * 已经有很多人讨论过这点，认为这种阅读体验对于代码来讲是不可能的\n    * [CODE IS NOT LETERATURE](https://gigamonkeys.com/code-reading/)\n  * 但我认为，代码并非是一个静止的东西，而是人对于**某种类型数据的可能性**的思考\n  * 它是个动态的，随着人思想的变化而变化的东西\n  * 所以仅仅从代码的一个版本出发，希望还原作者的整个思考过程，本身就是一种缘木求鱼的行为\n\n* env.js能改变什么？\n  * 不能改变什么本质上的东西，但能让维护和版本变化相关的文档变得**自然**\n  * 我们还是从文学编程的思路出发，我们希望作者按照其逻辑去组织代码版本\n  * 从软件的简单原型出发，每个版本增加一些功能，或修正一些bug，并保证每个版本都是可用的\n  * （我们编写软件本来就需要编写demo/测试之类的东西，所以我认为这一步没有增加额外的工作量）\n  * 而每个版本对应着一系列REPL，我们可以diff这些REPL，将代码的差异与功能的差异对应起来\n  * 最后，所有这些版本可以出现在同一个页面里，读者可以亲自尝试使用每个版本，比较它们之间的差异，甚至可以在新的REPL里程序化地测试它们\n  * 我把这称之为“先理解功能，后看到代码”\n\n* 有一点遗憾是，我本来计划展示如何使用这种方法编写env.js（200行左右），时间精力有限，放弃了，以后补上\n\n---\n* Q & A\n  * 如果有时间，首先把REPL的使用模式讲完\n\n  * env.js的下一步计划？\n    * 有很多计划\n    * 比较重要的是通过github api把env.js变成线上服务，这样我发布新版本会变得容易，对于其他人来讲也更有用\n    * 其次，现在env.js的文本编辑器还是最基本的textarea，完全依赖浏览器的默认行为，也没有任何代码高亮，很不好，得改\n    * 这个ppt当然也得写完整，可能在这个过程中会做出一个完整的ppt编辑功能来\n    * 现在ppt是靠css做的，css写ppt真的不算好用，最好是自己实现一个渲染后端，那样实际上把AfterEffect的活也干了…哈哈\n    * 可能性太多了，我很高兴自己在思考软件工程这个问题这么久之后得到一个至少我非常满意的结果\n  * 提问？\n`)\n})\n\n}",
  "skip(inited)\n$.css4(\"::selection\", { background: \"white\", color: \"#7c5a5a\" })\n$.css4(\"strong\", {fontSize:\"1.2em\"})",
  "style(document.body, {background:\"#7c5a5a\", color:\"white\"})\nstyle(document.body, {transition:\"background 1s\"})\n$.init1(), $.init2()\n$$.state = \"init\"",
  "$.p1({\n  t: {height:0},\n  au: {height:0},\n  subt: {fontSize:\"7em\", margin:\"1em 20%\"},\n  subt1: {fontSize:0},\n  subt3:\"是什么？\"\n})",
  "$.p1({\n  au: {margin:0},\n  i1: {margin:\"1em 10%\"},\n  subt: {transition:\"all 0.2s linear 0s\", fontSize:\"4em\", margin:\"1em 10%\"},\n  top: {top:\"5%\"},\n})",
  "$.p1({i2: {margin:\"1em 10%\"} })",
  "$.p1({i3: {margin:\"1em 10%\"} })",
  "$.p1({i4: {margin:\"1em 10%\"} })",
  "$.p1({top:{top:\"-100vh\"}})\n$.p2({top:{top:\"20%\"}})",
  "$.p2({i1: {margin:\"1em 10%\"} })",
  "$.p2({i2: {margin:\"1em 10%\"} })",
  "$.p2({i3: {margin:\"1em 10%\"} })",
  "$.p2({i4: {margin:\"1em 10%\"} })",
  "$.p2({t: {height:0}, t2: {height:200} })\nconst i = {height:0}\n$.p2({i1:i, i2:i, i3:i, i4:i})",
  "$.p2({i1: \"因为你的每个操作，都有程序员为它写好了相应的代码。\" })\n$.p2({i1:{height:50}, i2:\"当你点击关闭按钮，窗口之所以消失，那是因为程序员为你准备了使窗口消失的程序\" })",
  "$.p2({i2:{height:50}, i3:\"反过来说，如果没有人为你编写对应的功能，你就做不到相应的事情。\" })",
  "$.p2({i3:{height:50}, t:\"这意味着什么？\"})",
  "$.p2({t:{height:200}, t2:{height:0}})\nconst i = {height:0}\n$.p2({i1:i, i2:i, i3:i, i4:i})",
  "$.p2({i1: \"这意味着所有的交互，本质上是编程。\" })\n$.p2({i1:{height:50}, i2:\"程序是一个状态的集合，交互，实际上是在改变其中的状态。\" })",
  "$.p2({i2:{height:50}, i3:\"而改变程序状态最有效的，也是唯一的工具，就是编程。\" })",
  "$.p2({i3:{height:50}, i4:\"这引发了关于交互式开发的思考。\"})\n$.p2({t2:[\"第一节 状态的控制\", {fontSize:\"5em\"}]})",
  "$.p2({i4:{height:50}, top:{left:0}})",
  "$.p2({t:{height:0}, t2:{height:200, fontSize:\"10em\"}, top:{top:\"30%\"}})\nconst i = {height:0}; $.p2({i1:i, i2:i, i3:i, i4:i})\nstyle(document.body, {background:\"#485648\"})\nsleep(100).then(_=>$.p2({top:{top:\"35%\"}}))",
  "$.p2({top:{left:\"-200vw\"}})\n$.p3({top:{left:0}})",
  "$.p3({top:{top:\"5%\"}, repl:{opacity:\"1\", margin:\"0 auto\"}})\n$.p3({t:\"（这里点击框外的背景才能控制ppt进度）\"})",
  "$.p3({top:{left:\"-200vw\"}})\n$.p4({top:{left:0}})\nstyle(document.body, {background:\"#7c5a5a\"})",
  ""
]